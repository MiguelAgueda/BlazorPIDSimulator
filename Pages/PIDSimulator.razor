@page "/pid_sim"
@using System.Reactive.Linq
@using Components


<RadzenCard>
    Proportional Gain:
    <RadzenNumeric TItem="double" Placeholder="Enter Proportional Gain" @bind-Value=@p />
    Integral Gain:
    <RadzenNumeric TItem="double" Placeholder="Enter Integral Gain" @bind-Value=@i />
    Derivative Gain:
    <RadzenNumeric TItem="double" Placeholder="Enter Derivative Gain" @bind-Value=@d />
    Set Point:
    <RadzenNumeric TItem="double" Placeholder="Enter Set Point" @bind-Value=@setpoint />
    <RadzenButton Click="@SetPIDTerms" >Set PID Control Terms!</RadzenButton>
</RadzenCard>
<RadzenChart>
    <RadzenLineSeries Smooth="true" Data="@pidTimeSeries" ValueProperty="Output" CategoryProperty="TimeStep" />

    <RadzenValueAxis Min="0.0" Max="10000" Step="1000" >
      <RadzenAxisTitle Text="Revenue" />
    </RadzenValueAxis>

    <RadzenCategoryAxis>
      <RadzenAxisTitle Text="Time Step" />
    </RadzenCategoryAxis>

    <RadzenLineSeries Smooth="true" Data="@pidTimeSeries" ValueProperty="SetPoint" CategoryProperty="TimeStep" />

</RadzenChart>
<RadzenButton Click=@(args => StartLoop())>Start Update Loop</RadzenButton>
<RadzenButton Click=@(args => StopLoop())>Stop Update Loop</RadzenButton>

@code {
    class PIDTimeStep
    {
        public double SetPoint { get; set; } = 0.0;
        public double Error { get; set; }
        public double Output { get; set; }
        public int TimeStep { get; set; }
    }





    public int chartYMin = -5000;
    public int chartYMax = 5000;
    public int chartYStep = 1000;
    Queue<PIDTimeStep> pidTimeSeries { get; set; } = new Queue<PIDTimeStep>();
    
    Components.PID processPID = new Components.PID(0.0, 0.0, 0.0, 0.0, 255.0);
    Components.Plant plant = new Components.Plant(0.0, 9000.0);

    double p = 1.0;
    double i = 0.1;
    double d = 0.1;
    double setpoint = 800.0;
    public async void SetPIDTerms()
    {
        processPID.SetP(p);
        processPID.SetI(i);
        processPID.SetD(d);
        processPID.ResetIntegral();
    }

    private double input = 0.0;
    private bool continueUpdateLoop = false;
    private IObservable<long> Timer;
    private IDisposable TimerSub;
    public async Task StartLoop()
    {
        if (this.Timer == null)
        {
            this.Timer = Observable.Timer(TimeSpan.FromMilliseconds(0), TimeSpan.FromMilliseconds(100));
        }
        else
        {
            // NO-OP.
        }

        if (this.TimerSub == null)
        {
            PIDTimeStep firstEntry =
            new PIDTimeStep() { Error = 0.0, Output = 0.0, TimeStep = 1000 };
            pidTimeSeries.Enqueue(firstEntry);

            this.TimerSub = this.Timer.Subscribe(x => InvokeAsync(() => 
            {
                PIDTimeStep tempPIDItem = new PIDTimeStep();
                tempPIDItem.SetPoint = setpoint;
                tempPIDItem.Error = setpoint - plant.lastOutput;
                double plantInput = processPID.Update(tempPIDItem.Error);
                tempPIDItem.Output = plant.Update(plantInput);
                tempPIDItem.TimeStep = pidTimeSeries.Last().TimeStep + 1;
                pidTimeSeries.Enqueue(tempPIDItem);
                /* The follow if-body, when hit, stops the chart from updating. 
                 */
                if (pidTimeSeries.Count() > 30)
                    pidTimeSeries.Dequeue(); 
                StateHasChanged();
            }));
        }
        else
        {
            // NO-OP.
        }
    }

    public async void StopLoop()
    {
        this.TimerSub?.Dispose();
        this.TimerSub = null;
        this.pidTimeSeries.Clear();
        this.processPID.ResetIntegral();
    }
}
